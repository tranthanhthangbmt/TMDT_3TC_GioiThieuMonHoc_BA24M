<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Tr√¨nh ph√°t B√†i gi·∫£ng ‚Äî Auto‚ÄëScroll B·∫≠t S·∫µn</title>
  <style>
    :root {
      --bar-bg: rgba(0, 0, 0, 0.7);
      --bar-fg: #ffffff;
      --accent: #0d6efd;
      --ok: #28a745;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      margin: 0;
      background: #000;
      overflow: hidden;
      /* tr·∫£i nghi·ªám xem slide */
    }

    .player-container {
      background: #fff;
      width: 100vw;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      position: relative;
      /* ƒë·ªÉ ƒë·∫∑t thanh ƒëi·ªÅu khi·ªÉn */
    }

    /* Fallback cho Zalo/WebView kh√¥ng h·ªó tr·ª£ API Fullscreen */
    .player-container.pseudo-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 99999;
      width: 100%;
      height: 100%;
      background: #000;
    }

    /* üî• FORCE LANDSCAPE MODE (Cho Mobile Portrait) */
    .player-container.force-landscape {
      position: fixed;
      top: 0;
      left: 100vw;
      /* ƒê·∫©y sang m√©p ph·∫£i ƒë·ªÉ xoay v·ªÅ */
      width: 100vh;
      height: 100vw;
      z-index: 99999;
      background: #000;
      transform-origin: top left;
      transform: rotate(90deg);
      /* ·∫®n thanh cu·ªôn m·∫∑c ƒë·ªãnh n·∫øu c√≥ */
      overflow: hidden;
    }

    .slide-viewer {
      border: 1px solid #ddd;
      border-radius: 8px;
      overflow-y: auto;
      flex-grow: 1;
      position: relative;
      background: #000;
    }

    .slide-viewer img {
      width: 100%;
      height: auto;
      display: block;
    }

    /* Ch·∫ø ƒë·ªô Fit (kh√¥ng cu·ªôn) */
    .slide-viewer.fit-mode {
      overflow: hidden;
    }

    .slide-viewer.fit-mode img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    /* Thanh ƒëi·ªÅu khi·ªÉn d∆∞·ªõi c√πng */
    .bottom-bar {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 10px;
      /* TƒÉng padding bottom cho c√°c d√≤ng iPhone ƒë·ªùi m·ªõi */
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
      background: linear-gradient(to top, var(--bar-bg), transparent);
      transition: transform 0.35s ease-in-out;
      transform: translateY(0);
      color: var(--bar-fg);
    }

    /* ·∫®n thanh khi kh√¥ng t∆∞∆°ng t√°c */
    .player-container.inactive .bottom-bar {
      transform: translateY(100%);
    }

    .timeline-container {
      width: 100%;
      padding: 4px 0;
      margin-bottom: 6px;
    }

    .progress-bar-wrapper {
      background: rgba(255, 255, 255, 0.5);
      border-radius: 5px;
      cursor: pointer;
      padding: 4px 0;
    }

    .progress-bar {
      background: var(--accent);
      width: 0%;
      height: 8px;
      border-radius: 5px;
      transition: width 0.1s linear;
    }

    .time-display {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      margin-top: 4px;
      text-shadow: 1px 1px 2px #000;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .controls button {
      color: #fff;
      background: rgba(0, 0, 0, 0.3);
      border: none;
      border-radius: 50%;
      width: 44px;
      height: 44px;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.25s;
    }

    .controls button:hover {
      background: rgba(0, 0, 0, 0.45);
    }

    #play-pause-btn {
      background: var(--ok);
      width: 50px;
      height: 50px;
      font-size: 24px;
    }

    .slide-counter {
      flex: 1;
      text-align: center;
      font-weight: 700;
      text-shadow: 1px 1px 2px #000;
    }

    /* ===================== CSS M·ªöI CHO LOADING ===================== */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
      z-index: 10;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .loading-overlay.visible {
      visibility: visible;
      opacity: 1;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s infinite linear;
      margin-bottom: 10px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .loading-text {
      font-size: 14px;
      text-shadow: 1px 1px 2px #000;
    }
  </style>
</head>

<body>
  <div id="player-container" class="player-container">
    <div id="slide-viewer" class="slide-viewer" aria-label="Khu v·ª±c hi·ªÉn th·ªã slide" tabindex="0">
      <img id="slide-image" src="" alt="Slide" />
      <!-- Loading Overlay -->
      <div id="loading-overlay" class="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text" class="loading-text">ƒêang t·∫£i d·ªØ li·ªáu...</div>
      </div>
    </div>

    <div class="bottom-bar">
      <div class="timeline-container">
        <div id="progress-bar-wrapper" class="progress-bar-wrapper">
          <div id="progress-bar" class="progress-bar"></div>
        </div>
        <div class="time-display">
          <span id="current-time">00:00</span>
          <span id="total-duration">00:00</span>
        </div>
      </div>

      <div class="controls">
        <button id="prev-btn" title="Slide tr∆∞·ªõc">‚è™</button>
        <button id="play-pause-btn" title="Ph√°t/T·∫°m d·ª´ng">‚ñ∂Ô∏è</button>
        <div id="slide-counter" class="slide-counter">‚Äî / ‚Äî</div>
        <button id="next-btn" title="Slide ti·∫øp theo">‚è©</button>
        <button id="autoscroll-btn" title="B·∫≠t/T·∫Øt T·ª± cu·ªôn">üîÑ</button>
        <button id="scale-btn" title="Ch·∫ø ƒë·ªô xem">‚õ∂</button>
        <button id="fullscreen-btn" title="To√†n m√†n h√¨nh">üñºÔ∏è</button>
      </div>
    </div>

    <!-- Audio Element ·∫©n -->
    <audio id="slide-audio" preload="auto"></audio>
  </div>

  <script>
    /* ===================== C·∫§U H√åNH ===================== */
    const TOTAL_SLIDES = 17;
    const IMAGE_PREFIX = 'images/slide-';
    const AUDIO_PREFIX = 'audio/slide_';
    const IMG_EXT = '.png';
    const AUD_EXT = '.mp3';

    /* ==================== QU·∫¢N L√ù T√ÄI NGUY√äN (New) ==================== */
    class ResourceManager {
      constructor() {
        this.cache = new Map(); // L∆∞u tr·ªØ tr·∫°ng th√°i load: 'loading', 'loaded', 'error'
        this.blobs = new Map(); // L∆∞u tr·ªØ Blob URL n·∫øu c·∫ßn (nh∆∞ng ·ªü ƒë√¢y ta preload qua Image/Audio obj)
        this.maxRetries = 5;
        this.retryDelay = 1500; // ms
      }

      // T·∫°o key duy nh·∫•t cho resource
      getKey(type, index) { return `${type}_${index}`; }

      // T·∫£i ·∫£nh c√≥ retry
      loadImage(index) {
        const key = this.getKey('image', index);
        if (this.cache.has(key)) return this.cache.get(key);

        const src = `${IMAGE_PREFIX}${index}${IMG_EXT}`;
        const promise = new Promise((resolve, reject) => {
          let attempts = 0;

          const tryLoad = () => {
            attempts++;
            const img = new Image();
            img.src = src;
            img.onload = () => resolve(src); // Tr·∫£ v·ªÅ src g·ªëc v√¨ browser s·∫Ω cache
            img.onerror = () => {
              console.warn(`[Image] L·ªói t·∫£i slide ${index} (L·∫ßn ${attempts})`);
              if (attempts < this.maxRetries) {
                setTimeout(tryLoad, this.retryDelay * attempts); // Exponential backoff nh·∫π
              } else {
                reject(new Error(`Kh√¥ng th·ªÉ t·∫£i ·∫£nh slide ${index}`));
              }
            };
          };
          tryLoad();
        });

        this.cache.set(key, promise);
        return promise;
      }

      // T·∫£i audio c√≥ retry
      loadAudio(index) {
        const key = this.getKey('audio', index);
        if (this.cache.has(key)) return this.cache.get(key);

        const src = `${AUDIO_PREFIX}${index}${AUD_EXT}`;
        const promise = new Promise((resolve, reject) => {
          let attempts = 0;

          const tryLoad = () => {
            attempts++;
            // D√πng fetch ƒë·ªÉ ki·ªÉm tra ch·∫Øc ch·∫Øn file t·ªìn t·∫°i v√† t·∫£i v·ªÅ buffer d√≤ng ch·∫£y n·∫øu c·∫ßn
            // Tuy nhi√™n ƒë·ªÉ ƒë∆°n gi·∫£n v√† t·∫≠n d·ª•ng browser cache, ta d√πng Audio object
            const audio = new Audio();
            audio.preload = 'auto';
            audio.src = src;

            // X·ª≠ l√Ω s·ª± ki·ªán load
            const onSuccess = () => {
              cleanup();
              resolve(src);
            };
            const onError = () => {
              cleanup();
              console.warn(`[Audio] L·ªói t·∫£i audio ${index} (L·∫ßn ${attempts})`);
              if (attempts < this.maxRetries) {
                setTimeout(tryLoad, this.retryDelay * attempts);
              } else {
                reject(new Error(`Kh√¥ng th·ªÉ t·∫£i audio slide ${index}`));
              }
            };

            const cleanup = () => {
              audio.removeEventListener('canplaythrough', onSuccess);
              audio.removeEventListener('error', onError);
            };

            audio.addEventListener('canplaythrough', onSuccess); // ƒê·ªß d·ªØ li·ªáu ƒë·ªÉ ph√°t
            audio.addEventListener('error', onError);
            audio.load();
          };
          tryLoad();
        });

        this.cache.set(key, promise);
        return promise;
      }

      // T·∫£i c·∫£ b·ªô cho 1 slide
      loadSlide(index) {
        return Promise.all([
          this.loadImage(index),
          this.loadAudio(index)
        ]);
      }
    }

    /* ==================== BI·∫æN TO√ÄN C·ª§C ==================== */
    const resourceManager = new ResourceManager();
    const playerContainer = document.getElementById('player-container');
    const slideViewer = document.getElementById('slide-viewer');
    const slideImage = document.getElementById('slide-image');
    const slideAudio = document.getElementById('slide-audio');
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingText = document.getElementById('loading-text');

    const autoscrollBtn = document.getElementById('autoscroll-btn');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const slideCounter = document.getElementById('slide-counter');
    const scaleBtn = document.getElementById('scale-btn');
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    const progressBarWrap = document.getElementById('progress-bar-wrapper');
    const progressBar = document.getElementById('progress-bar');
    const currentTimeEl = document.getElementById('current-time');
    const totalDurationEl = document.getElementById('total-duration');

    let isFitMode = false;
    let scrollAnimationId = null;
    let currentSlideIndex = 1; // Slide b·∫Øt ƒë·∫ßu t·ª´ 1
    let isAutoscrollEnabled = true;

    /* ================= UI HELPER ================= */
    function showLoading(show, message = "ƒêang t·∫£i...") {
      loadingText.textContent = message;
      if (show) loadingOverlay.classList.add('visible');
      else loadingOverlay.classList.remove('visible');
    }

    function syncAutoscrollUI() {
      autoscrollBtn.classList.toggle('active', isAutoscrollEnabled);
    }

    /* ================= LOGIC CH√çNH ================= */
    async function showSlide(index) {
      // Validate index
      if (index < 1) index = 1;
      if (index > TOTAL_SLIDES) index = TOTAL_SLIDES;
      currentSlideIndex = index;

      // Stop current playback
      slideAudio.pause();
      cancelAnimationFrame(scrollAnimationId);
      showLoading(true, `ƒêang t·∫£i slide ${index}...`);

      // Update n√∫t ƒëi·ªÅu h∆∞·ªõng
      prevBtn.disabled = (index === 1);
      nextBtn.disabled = (index === TOTAL_SLIDES);
      slideCounter.textContent = `${index} / ${TOTAL_SLIDES}`;

      try {
        // 1. T·∫£i resources c·ªßa slide hi·ªán t·∫°i (ho·∫∑c l·∫•y t·ª´ cache)
        await resourceManager.loadSlide(index);

        // 2. G√°n source (l√∫c n√†y ƒë√£ n·∫±m trong cache tr√¨nh duy·ªát)
        slideImage.src = `${IMAGE_PREFIX}${index}${IMG_EXT}`;
        slideAudio.src = `${AUDIO_PREFIX}${index}${AUD_EXT}`;

        // 3. Reset view
        slideViewer.scrollTop = 0;
        showLoading(false);

        // 4. Ph√°t audio & Auto-scroll
        try {
          await slideAudio.play();
          startAutoScrollIfNeeded();
        } catch (err) {
          console.log("Autoplay blocked or waiting for interaction", err);
          playPauseBtn.innerHTML = '‚ñ∂Ô∏è'; // Hi·ªÉn th·ªã n√∫t play
        }

        // 5. Preload c√°c slide ti·∫øp theo (Chi·∫øn l∆∞·ª£c th√¥ng minh)
        preloadNextSlides(index);

      } catch (error) {
        console.error(error);
        showLoading(true, "M·∫°ng kh√¥ng ·ªïn ƒë·ªãnh. ƒêang th·ª≠ l·∫°i...");
        // T·ª± ƒë·ªông th·ª≠ l·∫°i sau 3s n·∫øu l·ªói
        setTimeout(() => showSlide(index), 3000);
      }
    }

    function preloadNextSlides(currentIndex) {
      // Preload 2 slide ti·∫øp theo
      for (let i = 1; i <= 2; i++) {
        const nextIdx = currentIndex + i;
        if (nextIdx <= TOTAL_SLIDES) {
          resourceManager.loadSlide(nextIdx).catch(err => console.log(`Preload failed for ${nextIdx}`, err));
        }
      }
    }

    /* ================== AUTO SCROLL & AUDIO ================== */
    function startAutoScrollIfNeeded() {
      if (isAutoscrollEnabled && !isFitMode && !slideAudio.paused && !slideAudio.ended) {
        cancelAnimationFrame(scrollAnimationId);
        scrollAnimationId = requestAnimationFrame(autoScroll);
      }
    }

    function autoScroll() {
      if (!isAutoscrollEnabled || isFitMode || slideAudio.paused || slideAudio.ended) return;
      const dur = slideAudio.duration || 0;
      const cur = slideAudio.currentTime || 0;
      if (dur > 0) {
        const scrollable = slideViewer.scrollHeight - slideViewer.clientHeight;
        const top = (cur / dur) * scrollable;
        slideViewer.scrollTop = top;
      }
      scrollAnimationId = requestAnimationFrame(autoScroll);
    }

    /* ================= LISTENERS ================= */
    slideAudio.addEventListener('play', () => {
      playPauseBtn.innerHTML = '‚è∏Ô∏è';
      startAutoScrollIfNeeded();
    });
    slideAudio.addEventListener('pause', () => {
      playPauseBtn.innerHTML = '‚ñ∂Ô∏è';
      cancelAnimationFrame(scrollAnimationId);
    });
    slideAudio.addEventListener('ended', () => {
      if (currentSlideIndex < TOTAL_SLIDES) {
        // T·ª± ƒë·ªông chuy·ªÉn slide ti·∫øp theo
        showSlide(currentSlideIndex + 1);
      }
    });

    // Time Update & Progress Bar
    slideAudio.addEventListener('timeupdate', () => {
      if (!isNaN(slideAudio.duration) && slideAudio.duration > 0) {
        const pct = (slideAudio.currentTime / slideAudio.duration) * 100;
        progressBar.style.width = `${pct}%`;
        currentTimeEl.textContent = formatTime(slideAudio.currentTime);
      }
    });
    slideAudio.addEventListener('loadedmetadata', () => {
      if (!isNaN(slideAudio.duration)) totalDurationEl.textContent = formatTime(slideAudio.duration);
    });

    // Seek
    progressBarWrap.addEventListener('click', (ev) => {
      if (!slideAudio.duration) return;
      const rect = progressBarWrap.getBoundingClientRect();
      const ratio = (ev.clientX - rect.left) / rect.width;
      slideAudio.currentTime = ratio * slideAudio.duration;
    });

    // Buttons
    playPauseBtn.addEventListener('click', () => {
      if (slideAudio.paused) slideAudio.play();
      else slideAudio.pause();
    });

    prevBtn.addEventListener('click', () => {
      if (currentSlideIndex > 1) showSlide(currentSlideIndex - 1);
    });

    nextBtn.addEventListener('click', () => {
      if (currentSlideIndex < TOTAL_SLIDES) showSlide(currentSlideIndex + 1);
    });

    autoscrollBtn.addEventListener('click', () => {
      isAutoscrollEnabled = !isAutoscrollEnabled;
      syncAutoscrollUI();
      if (isAutoscrollEnabled) startAutoScrollIfNeeded();
      else cancelAnimationFrame(scrollAnimationId);
    });

    scaleBtn.addEventListener('click', () => {
      isFitMode = !isFitMode;
      slideViewer.classList.toggle('fit-mode', isFitMode);
      scaleBtn.innerHTML = isFitMode ? '‚ÜïÔ∏è' : '‚õ∂';
      if (isFitMode) cancelAnimationFrame(scrollAnimationId);
      else startAutoScrollIfNeeded();
    });

    // Fullscreen logic c·∫£i ti·∫øn cho Zalo
    function toggleFullscreen() {
      // Ki·ªÉm tra xem c√≥ ƒëang ·ªü ch·∫ø ƒë·ªô pseudo-fullscreen kh√¥ng
      const isPseudo = playerContainer.classList.contains('pseudo-fullscreen');
      const isNative = !!document.fullscreenElement;

      if (!isNative && !isPseudo) {
        // Th·ª≠ b·∫≠t fullscreen native
        document.documentElement.requestFullscreen()
          .then(() => {
            // Th√†nh c√¥ng native
            screen.orientation.lock('landscape').catch(() => { });
          })
          .catch(err => {
            console.log("Fullscreen native b·ªã ch·∫∑n, chuy·ªÉn sang ch·∫ø ƒë·ªô gi·∫£ l·∫≠p (Zalo/Webview)", err);
            // Fallback: Maximize container b·∫±ng CSS
            playerContainer.classList.add('pseudo-fullscreen');
            fullscreenBtn.innerHTML = 'X';

            // √âp xoay ngang n·∫øu c√≥ th·ªÉ
            if (screen.orientation && typeof screen.orientation.lock === 'function') {
              screen.orientation.lock('landscape').catch(() => { });
            }
          });
      } else {
        // ƒêang full (native ho·∫∑c pseudo) -> Tho√°t
        if (isNative) {
          document.exitFullscreen();
        }
        playerContainer.classList.remove('pseudo-fullscreen');
        fullscreenBtn.innerHTML = 'üñºÔ∏è';

        if (screen.orientation && typeof screen.orientation.unlock === 'function') {
          screen.orientation.unlock();
        }
      }
    }
    fullscreenBtn.addEventListener('click', toggleFullscreen);

    // L·∫Øng nghe thay ƒë·ªïi native ƒë·ªÉ c·∫≠p nh·∫≠t n√∫t v√† class
    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement) {
        // Ng∆∞·ªùi d√πng tho√°t b·∫±ng n√∫t ESC ho·∫∑c vu·ªët
        playerContainer.classList.remove('pseudo-fullscreen');
        fullscreenBtn.innerHTML = 'üñºÔ∏è';
      } else {
        fullscreenBtn.innerHTML = 'X';
      }
    });

    // Controls Visibility
    let inactivityTimer;
    function showControlsAndResetTimer() {
      playerContainer.classList.remove('inactive');
      clearTimeout(inactivityTimer);
      inactivityTimer = setTimeout(() => {
        if (!slideAudio.paused) playerContainer.classList.add('inactive');
      }, 3000);
    }
    playerContainer.addEventListener('mousemove', showControlsAndResetTimer);
    playerContainer.addEventListener('click', showControlsAndResetTimer);
    playerContainer.addEventListener('touchstart', showControlsAndResetTimer);

    // Helpers
    function formatTime(sec) {
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    /* ================= üî• T·ª∞ ƒê·ªòNG XOAY NGANG (FORCED LANDSCAPE) ================= */
    function checkOrientation() {
      // Ph√°t hi·ªán thi·∫øt b·ªã di ƒë·ªông c∆° b·∫£n
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

      // N·∫øu l√† mobile V√Ä m√†n h√¨nh ƒëang ·ªü chi·ªÅu d·ªçc (cao > r·ªông)
      if (isMobile && window.innerHeight > window.innerWidth) {
        playerContainer.classList.add('force-landscape');
      } else {
        playerContainer.classList.remove('force-landscape');
      }
    }

    // L·∫Øng nghe s·ª± ki·ªán xoay v√† resize
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);

    /* ================= INIT ================= */
    window.addEventListener('load', () => {
      showControlsAndResetTimer();
      syncAutoscrollUI();
      checkOrientation(); // Ki·ªÉm tra h∆∞·ªõng ngay khi t·∫£i
      // B·∫Øt ƒë·∫ßu
      showSlide(currentSlideIndex);
    });
  </script>
</body>

</html>